<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Harten ‚Äì AI You Can Actually Trust (Full Demo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --cyan: #50e3c2;
      --blue: #4a90e2;
      --red: #ff6b6b;
      --bg: #0b0f19;
      --surface: #111827;
    }
    * {
      box-sizing: border-box;
      margin: 0;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: #fff;
      scroll-behavior: smooth;
      overflow-x: hidden;
    }
    section {
      position: relative;
      padding: 10vh 6vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    h1, h2 {
      font-weight: 800;
      letter-spacing: -0.03em;
      line-height: 1.1;
      text-align: center;
    }
    h1 {
      font-size: clamp(2.5rem, 6vw, 5rem);
    }
    h2 {
      font-size: clamp(2rem, 4vw, 3.5rem);
    }
    p {
      max-width: 55ch;
      text-align: center;
      color: #cbd5e1;
      margin: 1rem 0 2rem;
    }
    .btn {
      background: linear-gradient(135deg, var(--cyan), var(--blue));
      border: none;
      color: #fff;
      padding: 1rem 2rem;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.2s;
      box-shadow: 0 0 20px 4px var(--cyan), 0 0 40px 12px var(--blue);
      animation: glow 2s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from {
        box-shadow: 0 0 20px 4px var(--cyan), 0 0 40px 12px var(--blue);
      }
      to {
        box-shadow: 0 0 30px 8px var(--cyan), 0 0 60px 20px var(--blue);
      }
    }
    .btn:hover {
      transform: scale(1.05);
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    .content {
      position: relative;
      z-index: 1;
    }
    .grid {
      display: grid;
      gap: 2rem;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      width: 100%;
      max-width: 1100px;
    }
    .card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 1.5rem;
      padding: 2rem;
      backdrop-filter: blur(10px);
      transition: transform 0.3s, border-color 0.3s;
    }
    .card:hover {
      transform: translateY(-6px) rotate(-1deg);
      border-color: var(--cyan);
    }
    .card h3 {
      margin: 1rem 0 0.5rem;
    }
    .trust {
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .trust div {
      text-align: center;
    }
    .trust div div {
      font-size: 2.5rem;
    }
    iframe {
      border-radius: 1.5rem;
      margin-top: 2rem;
    }
    /* TRUST LAYER CITATIONS */
    .trust-demo {
      position: relative;
      max-width: 700px;
      margin: 2rem auto;
      background: var(--surface);
      border-radius: 1rem;
      padding: 2rem;
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .claim {
      position: relative;
      color: #fff;
      cursor: pointer;
      border-bottom: 1px dashed var(--cyan);
    }
    .citation {
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 0.5rem;
      background: var(--cyan);
      color: #000;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.8rem;
      display: none;
      z-index: 10;
    }
    .claim:hover .citation {
      display: block;
    }
    /* MORPH DEMO */
    .morph-demo {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      margin-top: 2rem;
    }
    .morph-stage {
      width: 80%;
      max-width: 600px;
      height: 400px;
      background: #000;
      border-radius: 1rem;
      position: relative;
      overflow: hidden;
    }
    .morph-stage > * {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    .slide-deck {
      display: none;
      flex-direction: column;
      gap: 1rem;
      padding: 2rem;
    }
    .slide {
      background: #fff;
      color: #000;
      border-radius: 0.5rem;
      padding: 1rem;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* SPEED RACE */
    .speed-race {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 80%;
      max-width: 600px;
      margin-top: 2rem;
    }
    .bar {
      height: 2rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      overflow: hidden;
    }
    .bar-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
    }
    .other-bar {
      background: var(--red);
    }
    .harten-bar {
      background: var(--cyan);
    }
    /* MEMORY WEB */
    #memoryCanvas {
      margin-top: 2rem;
      border-radius: 1rem;
      background: #000;
    }
    /* ACCESSIBILITY */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
        transition: none !important;
      }
    }
    /* KEYBOARD NAV */
    a, button, iframe {
      outline: 2px solid transparent;
    }
    a:focus, button:focus, iframe:focus {
      outline: 2px solid var(--cyan);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <!-- HERO -->
  <section id="hero">
    <div class="content">
      <h1>AI You Can Actually Trust</h1>
      <p>The only platform that combines multiple models, shows its work, and never slows down.</p>
      <button class="btn">Try It Free ‚Äì No Credit Card</button>
    </div>
    <canvas id="heroCanvas"></canvas>
  </section>

  <!-- PROBLEM -->
  <section id="problem">
    <h2>You Can‚Äôt Trust Current AI for Work That Matters</h2>
    <div class="grid">
      <div class="card"><div>ü§ñ</div><h3>Sounds confident, but wrong</h3><p>ChatGPT-style hallucinations cost you credibility.</p></div>
      <div class="card"><div>üåÄ</div><h3>Which AI do I even use?</h3><p>Constantly juggling GPT vs Claude vs Gemini.</p></div>
      <div class="card"><div>üí¨</div><h3>Forgets everything</h3><p>Hits context limits and wipes the slate clean.</p></div>
      <div class="card"><div>üìÑ</div><h3>Text only, no deliverables</h3><p>You still format slides, code, docs yourself.</p></div>
    </div>
  </section>

  <!-- SOLUTION -->
  <section id="solution">
    <h2>Smarter Than Any Single AI</h2>
    <canvas id="solutionCanvas"></canvas>
  </section>

  <!-- TRUST LAYER -->
  <section id="trustLayer">
    <h2>See Why You Can Trust It</h2>
    <div class="trust-demo">
      <p>
        Photosynthesis is the process by which plants use sunlight, water, and CO‚ÇÇ to produce glucose and oxygen.
        <span class="claim">
          This reaction occurs in chloroplasts.
          <span class="citation">Source: doi.org/10.1093/aob/mcab123</span>
        </span>
        The light-dependent reactions produce ATP and NADPH, which power the Calvin cycle.
        <span class="claim">
          Multiple models cross-validated this answer.
          <span class="citation">Claude + GPT-4 + Gemini agree</span>
        </span>
      </p>
    </div>
  </section>

  <!-- MORPH -->
  <section id="morph">
    <h2>Creates Real Outputs, Not Just Text</h2>
    <div class="morph-demo">
      <button class="btn" onclick="startMorph()">Watch text become slides ‚Üí</button>
      <div class="morph-stage">
        <div id="morphText">‚ÄúCreate a business presentation on AI trends‚Äù</div>
        <div class="slide-deck" id="slideDeck">
          <div class="slide">Slide 1: AI Market Overview</div>
          <div class="slide">Slide 2: Key Trends 2025</div>
          <div class="slide">Slide 3: Strategic Recommendations</div>
        </div>
      </div>
    </div>
  </section>

  <!-- SPEED RACE -->
  <section id="speed">
    <h2>Never Hits Limits. Never Slows Down.</h2>
    <div class="speed-race">
      <div class="bar"><div class="bar-fill other-bar" id="otherBar"></div></div>
      <p>Other AI (context limit hit ‚Üí freeze)</p>
      <div class="bar"><div class="bar-fill harten-bar" id="hartenBar"></div></div>
      <p>Harten (constant speed, unlimited context)</p>
    </div>
  </section>

  <!-- MEMORY WEB -->
  <section id="memory">
    <h2>Remembers Everything You Work On</h2>
    <canvas id="memoryCanvas"></canvas>
  </section>

  <!-- TRUST -->
  <section id="trust">
    <h2>Built Different</h2>
    <div class="trust">
      <div><div>üîì</div><h3>Complete Transparency</h3></div>
      <div><div>üõ°Ô∏è</div><h3>Verified Accuracy</h3></div>
      <div><div>‚ôæÔ∏è</div><h3>Unlimited Reliability</h3></div>
    </div>
  </section>

  <!-- FORM -->
  <section id="form">
    <h2>Start Building Trust Today</h2>
    <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSc7LdkE1HKN3HtJ5b5cF7pDG5YfRcG5P5k5Q5Q5Q5Q5Q5Q5Q/viewform?embedded=true" width="100%" height="600" frameborder="0">Loading‚Ä¶</iframe>
  </section>

  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/ScrollTrigger.min.js"></script>

  <script>
    gsap.registerPlugin(ScrollTrigger);

    /* ---------- HERO WEBGL ---------- */
    function initHero() {
      const canvas = document.getElementById("heroCanvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 10;

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(5, 5, 5);
      scene.add(dir);

      const starGeo = new THREE.BufferGeometry();
      const starCount = 2000;
      const pos = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount * 3; i++) pos[i] = (Math.random() - 0.5) * 100;
      starGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15 });
      scene.add(new THREE.Points(starGeo, starMat));

      function textSprite(txt, color = "#ffffff") {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        c.width = 512;
        c.height = 128;
        ctx.fillStyle = color;
        ctx.font = "bold 48px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(txt, 256, 64);
        const tex = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
        return new THREE.Sprite(mat);
      }

      const leftGroup = new THREE.Group();
      const leftSprite = textSprite("Other AI", "#ff6b6b");
      leftSprite.scale.set(4, 1, 1);
      leftGroup.add(leftSprite);
      const leftBox = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.4, 0.2),
        new THREE.MeshStandardMaterial({ color: "#ff6b6b", emissive: "#ff6b6b", emissiveIntensity: 0.3 })
      );
      leftBox.position.y = -1;
      leftGroup.add(leftBox);
      leftGroup.position.x = -3;
      scene.add(leftGroup);

      const rightGroup = new THREE.Group();
      const rightSprite = textSprite("Harten", "#50e3c2");
      rightSprite.scale.set(4, 1, 1);
      rightGroup.add(rightSprite);
      const trustRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.5, 0.1, 16, 100),
        new THREE.MeshStandardMaterial({ color: "#50e3c2", emissive: "#50e3c2", emissiveIntensity: 0.6 })
      );
      trustRing.position.y = -0.8;
      rightGroup.add(trustRing);
      const trustText = textSprite("Trust: 97%", "#50e3c2");
      trustText.scale.set(2, 0.5, 1);
      trustText.position.y = -1.6;
      rightGroup.add(trustText);
      rightGroup.position.x = 3;
      scene.add(rightGroup);

      let hoverSide = null;
      canvas.addEventListener("pointermove", (e) => {
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        hoverSide = x < 0 ? "left" : "right";
      });
      canvas.addEventListener("pointerleave", () => (hoverSide = null));

      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        if (hoverSide === "left") {
          leftGroup.rotation.y = Math.sin(t * 4) * 0.2;
          leftGroup.position.y = Math.sin(t * 6) * 0.1;
        }
        if (hoverSide === "right") {
          rightGroup.rotation.y = Math.sin(t * 2) * 0.1;
          rightGroup.position.y = Math.sin(t * 3) * 0.05;
        }
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    /* ---------- SOLUTION ORCHESTRATION ---------- */
    function initSolution() {
      const canvas = document.getElementById("solutionCanvas");
      const container = canvas.parentElement;
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, 400);
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, container.clientWidth / 400, 0.1, 100);
      camera.position.z = 10;

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(5, 5, 5);
      scene.add(dir);

      const nodes = [
        { pos: [-2, 0, 0], color: 0x4a90e2, name: "Claude" },
        { pos: [2, 0, 0], color: 0xff6b6b, name: "GPT-4" },
        { pos: [0, 2, 0], color: 0x50e3c2, name: "Gemini" },
      ];

      nodes.forEach((n) => {
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 32, 32),
          new THREE.MeshStandardMaterial({ color: n.color, emissive: n.color, emissiveIntensity: 0.5 })
        );
        mesh.position.set(...n.pos);
        scene.add(mesh);
        const sprite = textSprite(n.name, "#" + n.color.toString(16).padStart(6, "0"));
        sprite.scale.set(2, 0.5, 1);
        sprite.position.set(n.pos[0], n.pos[1] - 0.7, n.pos[2]);
        scene.add(sprite);
      });

      const count = 200;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        pos.set([(Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4], i * 3);
      }
      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 }));
      scene.add(pts);

      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        const positions = pts.geometry.attributes.position.array;
        for (let i = 0; i < count; i++) {
          positions[i * 3 + 1] += Math.sin(t + positions[i * 3]) * 0.01;
        }
        pts.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = container.clientWidth / 400;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, 400);
      });
    }

    /* ---------- TEXT SPRITE UTIL ---------- */
    function textSprite(txt, color = "#ffffff") {
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");
      c.width = 512;
      c.height = 128;
      ctx.fillStyle = color;
      ctx.font = "bold 48px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(txt, 256, 64);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      return new THREE.Sprite(mat);
    }

    /* ---------- MORPH ---------- */
    function startMorph() {
      const text = document.getElementById("morphText");
      const deck = document.getElementById("slideDeck");
      gsap.to(text, { opacity: 0, duration: 0.6, onComplete: () => {
        text.style.display = "none";
        deck.style.display = "flex";
        gsap.from(deck.children, { scale: 0.8, opacity: 0, stagger: 0.15, duration: 0.6 });
      }});
    }

    /* ---------- SPEED RACE ---------- */
    ScrollTrigger.create({
      trigger: "#speed",
      onEnter: () => {
        gsap.to("#otherBar", { width: "45%", duration: 1.5, ease: "power2.in" });
        gsap.to("#hartenBar", { width: "100%", duration: 3, ease: "none" });
      }
    });

    /* ---------- MEMORY WEB ---------- */
    function initMemory() {
      const canvas = document.getElementById("memoryCanvas");
      const container = canvas.parentElement;
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, 400);
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, container.clientWidth / 400, 0.1, 100);
      camera.position.z = 10;

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(5, 5, 5);
      scene.add(dir);

      const nodes = [];
      for (let i = 0; i < 20; i++) {
        const n = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 16, 16),
          new THREE.MeshBasicMaterial({ color: 0x444444 })
        );
        n.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 6, 0);
        scene.add(n);
        nodes.push(n);
      }

      const lines = [];
      for (let i = 0; i < 10; i++) {
        const a = nodes[Math.floor(Math.random() * nodes.length)];
        const b = nodes[Math.floor(Math.random() * nodes.length)];
        if (a === b) continue;
        const geo = new THREE.BufferGeometry().setFromPoints([a.position, b.position]);
        const mat = new THREE.LineBasicMaterial({ color: 0x50e3c2, transparent: true, opacity: 0 });
        const line = new THREE.Line(geo, mat);
        scene.add(line);
        lines.push(mat);
      }

      let idx = 0;
      setInterval(() => {
        nodes.forEach((n) => n.material.color.set(0x444444));
        lines.forEach((l) => (l.opacity = 0));
        const active = nodes[idx % nodes.length];
        active.material.color.set(0x50e3c2);
        lines[idx % lines.length].opacity = 1;
        idx++;
      }, 800);

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = container.clientWidth / 400;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, 400);
      });
    }

    /* ---------- SCROLL FADES ---------- */
    gsap.utils.toArray("section").forEach((sec) => {
      gsap.from(sec.querySelectorAll("h2, p, .grid, .trust, .trust-demo, .morph-demo, .speed-race"), {
        y: 60,
        opacity: 0,
        duration: 0.9,
        stagger: 0.1,
        scrollTrigger: {
          trigger: sec,
          start: "top 80%",
        },
      });
    });

    /* ---------- KICK OFF ---------- */
    initHero();
    initSolution();
    initMemory();
  </script>
</body>
</html>
